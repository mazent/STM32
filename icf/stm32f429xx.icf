/*
	2048 KiB flash
	 256 KiB ram (192 + 64)

	| Settore |         Indirizzi         | KiB |
	+---------+---------------------------+-----+
    |     0   | 0x0800 0000 - 0x0800 3FFF |  16 |
    |     1   | 0x0800 4000 - 0x0800 7FFF |  16 |
    |     2   | 0x0800 8000 - 0x0800 BFFF |  16 |
    |     3   | 0x0800 C000 - 0x0800 FFFF |  16 |
    |     4   | 0x0801 0000 - 0x0801 FFFF |  64 |
    |     5   | 0x0802 0000 - 0x0803 FFFF | 128 |
    |     6   | 0x0804 0000 - 0x0805 FFFF | 128 |
    |     7   | 0x0806 0000 - 0x0807 FFFF | 128 |
    |     8   | 0x0808 0000 - 0x0809 FFFF | 128 |
    |     9   | 0x080A 0000 - 0x080B FFFF | 128 |
    |    10   | 0x080C 0000 - 0x080D FFFF | 128 |
    |    11   | 0x080E 0000 - 0x080F FFFF | 128 |
    |    12   | 0x0810 0000 - 0x0810 3FFF |  16 |
    |    13   | 0x0810 4000 - 0x0810 7FFF |  16 |   
    |    14   | 0x0810 8000 - 0x0810 BFFF |  16 |   
    |    15   | 0x0810 C000 - 0x0810 FFFF |  16 |   
    |    16   | 0x0811 0000 - 0x0811 FFFF |  64 |   
    |    17   | 0x0812 0000 - 0x0813 FFFF | 128 |
    |    18   | 0x0814 0000 - 0x0815 FFFF | 128 |   
    |    19   | 0x0816 0000 - 0x0817 FFFF | 128 |
    |    20   | 0x0818 0000 - 0x0819 FFFF | 128 |
    |    21   | 0x081A 0000 - 0x081B FFFF | 128 |
    |    22   | 0x081C 0000 - 0x081D FFFF | 128 |
    |    23   | 0x081E 0000 - 0x081F FFFF | 128 |
    +---------+---------------------------+-----+
*/

define memory mem with size = 4G;

define symbol ROM_INIZIO = 0x08000000 ;
define symbol ROM_FINE   = 0x081FFFFF ;

define symbol CCM_INIZIO = 0x10000000 ;
define symbol CCM_FINE   = 0x1000FFFF ;

define symbol RAM_INIZIO = 0x20000000 ;
define symbol RAM_FINE   = 0x2002FFFF ;

define symbol BKPSRAM_INIZIO = 0x40024000 ;
define symbol BKPSRAM_FINE   = 0x40024FFF ;


// Questi ci sono sempre

define block CSTACK with alignment = 8, size = STACK_DIM { } ;
define block HEAP   with alignment = 8, size = HEAP_DIM  { } ;

initialize by copy { readwrite };
do not initialize  { section .noinit } ;


/*  promemoria
	define memory [ name ] with size = size_expr [ ,unit-size ];
		Definisce uno spazio di indirizzi

	define region name = region-expr;
		Definisce uno spazio fisico, cioe' disponibile

		[ memory-name: ][from expr { to expr | size expr } [repeat expr [ displacement expr ]]]

	define block name [ with param, param... ]
	    Raggruppa sezioni, nel codice: __section_begin, __section_end, __section_size (in asm: SFB, SFE, SIZEOF)
	    
		param	size = expr
				maximum size = expr
				alignment = expr
				fixed order
	{
		extended-selectors
	}
	[except
	{
		section_selectors
	}];

	[ "name": ] place at { address [ memory: ] expr | start of region_expr | end of region_expr }
	{
		extended-selectors
	}
	[except
	{
		section-selectors
	}];

	Espressioni
		expression binop expression
			binop +, -, *, /, %, <<, >>, <, >, ==, !=, &, ^, |, &&, ||
		unop expression
			unop +, -, !, ~
		expression ? expression : expression
		(expression)
		number
			nr [K|M|G|T|P]
		symbol
			define [ exported ] symbol name = expr;
		func-operator
			minimum(expr,expr)  Returns the smallest of the two parameters.
			maximum(expr,expr)  Returns the largest of the two parameters.
			isempty(r)  		Returns True if the region is empty, otherwise False.
			isdefinedsymbol(expr-symbol)
								Returns True if the expression symbol is defined, otherwise False.
			start(r)  			Returns the lowest address in the region.
			end(r)  			Returns the highest address in the region.
			size(r)  			Returns the size of the complete region.

			
    Per l'analisi dello stack:
        nel file .suc:
            call graph root [task] : nome-funzione ;
        se e' static non funziona, occorre usare:
            #pragma call_graph_root="task"
        subito prima della funzione
*/

